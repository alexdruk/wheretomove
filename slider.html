<!DOCTYPE html>
<html lang="en">
  <head>
    <title>D3 v7 Example</title>
    <style>
      body {
        font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
        font-size: 15pt;
      }
      h1 {
        text-align: center;
        font-weight: 500;
      }
      svg {
        display: block;
        margin: auto;
        border: 1px solid #eee;
      }
      #menu {
        position: relative;
        top: 90px;
        left: 50px;
      }

      #menu .item {
        margin-bottom: 12px;
        display: block;
      }

      #menu .item input {
        width: 150px;
      }

      #menu .item .value {
        font-weight: bold;
      }

      #menu .item span,
      #menu .item input {
        vertical-align: middle;
      }

      #menu .item .low {
        display: inline-block;
        width: 30px;
        text-align: right;
        font-size: smaller;
      }
      #menu .item .high {
        font-size: smaller;
      }
      .label {
        margin: auto;
        font-size: smaller;
        text-align: center;
      }
      .row {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        width: 100%;
      }

      .column {
        display: flex;
        flex-direction: column;
        flex-basis: 100%;
        flex: auto;
        align-items: center;
      }
      /* Tooltip */
      div.tooltip {
        position: absolute;
        visibility: hidden;
        font-size: 60%;
        color: #333333;
        background-color: #e6e6e6;
        opacity: 0.95;
        padding: 5px;
      }
      .cardcontainer {
        align-items: center;
        justify-content: center;
        margin-top: 50px;
        margin-left: auto;
        margin-right: auto;
        display: flex;
        flex-wrap: wrap;
        width: 80%;
      }
      .card {
        /* Add shadows to create the "card" effect */
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
        transition: 0.3s;
        padding: 2px 16px;
        font-size: smaller;
        width: 100%;
        margin-bottom: 10px;
      }

      /* On mouse-over, add a deeper shadow */
      .card:hover {
        box-shadow: 0 8px 16px 0 rgba(0, 0, 0, 0.2);
      }

      .source {
        font-style: italic;
        font-size: small;
        margin-left: 10px;
      }
      h4 {
        margin-top: 0;
        margin-bottom: 0;
        margin-left: 0px;
      }
      p {
        margin-top: 2px;
        margin-bottom: 2px;
      }
      .remove {
        background-color: #faf1f1;
      }
      .addbutton {
        background-color: #ecfaed;
      }
      .slider {
        overflow-x: auto;
      }
      /* Responsive layout - makes the two columns stack on top of each other instead of next to each other */
      @media only screen and (max-width: 1000px) {
        .row {
          /* it place the items in vertical direction */
          flex-direction: column;
        }
        .column {
          width: 100%;
        }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3.1.0/dist/topojson-client.min.js"></script>
  </head>
  <body>
    <h1>Slider</h1>
    <div class="row">
      <div class="column">
        <div id="menu">
          <div class="slider item" id="sunshineSlider" style="display: none">
            <div class="label">
              Sunshine (<span class="val" id="sunshineVal">5</span>)
            </div>
            <div>
              <button
                class="remove"
                type="button"
                onClick="removeById('sunshine')"
              >
                <span> &#215; </span>
              </button>
              <span class="low">1</span>
              <input
                type="range"
                min="1"
                max="10"
                value="5"
                class="slider"
                id="sunshine"
                onchange="changeColor()"
              />
              <span class="high">10</span>
            </div>
          </div>
          <!--- end of slider -->
          <div class="slider item" id="heatwavesSlider" style="display: none">
            <div class="label">
              Heat Waves (<span class="val" id="heatwavesVal">5</span>)
            </div>
            <div>
              <button
                class="remove"
                type="button"
                onClick="removeById('heatwaves')"
              >
                <span> &#215; </span>
              </button>
              <span class="low">1</span>
              <input
                type="range"
                min="1"
                max="10"
                value="5"
                class="slider"
                id="heatwaves"
                onchange="changeColor()"
              />
              <span class="high">10</span>
            </div>
          </div>
          <!--- end of slider -->
        </div>
        <!-- end of menu -->
      </div>
      <!-- end of column -->
      <div class="column" style="margin-left: 30px">&nbsp;&nbsp;</div>
      <div class="column" style="margin-top: 80px">
        <div id="map"></div>
        <!--div class="tooltip"></div-->
      </div>
      <!-- end of column -->
    </div>
    <!-- end of row -->
    <div class="cardcontainer">
      <div class="row">
        <div class="card" id="sunshineLine">
          <table>
            <tr>
              <td style="padding: 15px">
                <button
                  type="button"
                  class="addbutton"
                  onClick="addById('sunshine')"
                >
                  <span>&#43; add</span>
                </button>
              </td>
              <td>
                <h4>Sunshine</h4>
                <p>
                  Cummulative daily sunlight (1979-2011), deviation from
                  average, % of maximum
                </p>
                <p class="source">
                  Source:
                  <a href="http://wonder.cdc.gov/NASA-INSOLAR.html"
                    >North America Land Data Assimilation System (NLDAS) Daily
                    Sunlight (insolation) for years 1991-2011 on CDC</a
                  >
                </p>
              </td>
            </tr>
          </table>
        </div>
      </div>
      <!-- end of row -->
      <div class="row">
        <div class="card" id="heatwavesLine">
          <table>
            <tr>
              <td style="padding: 15px">
                <button
                  type="button"
                  class="addbutton"
                  onClick="addById('heatwaves')"
                >
                  <span>&#43; add</span>
                </button>
              </td>
              <td>
                <h4>Heat Waves</h4>
                <p>
                  Number of heat wave days in May-September (1981-2010), % of
                  maximum
                </p>
                <p class="source">
                  Source:
                  <a
                    href="https://wonder.cdc.gov/NCA-heatwavedays-historic.html"
                    >CDC WONDER</a
                  >
                </p>
              </td>
            </tr>
          </table>
        </div>
      </div>
      <!-- end of row -->
    </div>
    <script>
      // Copyright 2021 Observable, Inc.
      // Released under the ISC license.
      // https://observablehq.com/@d3/choropleth
      let data, us;
      const range = d3.schemeGreens[9];
      async function getDataFromFiles() {
        [data, us] = await Promise.all([
          d3.csv("final.csv"),
          d3.json("counties-albers-10m.json"),
        ]);
        excludeAlaska();
      }
      async function ready() {
        await getDataFromFiles();
        // document.getElementById("map").innerHTML = "";
        const newData = processInputs(data);
        // console.table(sortDataDesc(data, "result"));
        const counties = topojson.feature(us, us.objects.counties);
        const statemap = new Map(
          topojson.feature(us, us.objects.states).features.map((d) => [d.id, d])
        );
        const statemesh = topojson.mesh(
          us,
          us.objects.states,
          (a, b) => a !== b
        );
        // const range = d3.schemeGreens[9];
        // const scale = d3.Sequential;
        const scale = d3.scaleQuantize;
        const domain = [0, getInputs().length]; // should be number of questions
        // const domain = [0, 10]; // should be number of questions

        Choropleth(newData, {
          id: (d) => d.fips_id,
          value: (d) => d.result,
          scale: scale,
          domain: domain,
          range: range,
          title: (f, d) =>
            `${f.properties.name}, ${
              statemap.get(f.id.slice(0, 2)).properties.name
            }`,
          features: counties,
          borders: statemesh,
          //   county_borders: counties,
          width: 975,
          height: 610,
        });
        // Legend(scale(domain, range), {
        //   title: "Unemployment rank (%)",
        // });

        function Choropleth(
          newData,
          {
            id = (d) => d.id, // given d in data, returns the feature id
            value = () => undefined, // given d in data, returns the quantitative value
            title, // given a feature f and possibly a datum d, returns the hover text
            format, // optional format specifier for the title
            // scale = d3.scaleSequential, // type of color scale
            scale = d3.scaleQuantize, // type of color scale
            domain, // [min, max] values; input of color scale
            range = d3.interpolateGreens, // output of color scale
            // width = 640, // outer width, in pixels
            width = 975, // outer width, in pixels
            height, // outer height, in pixels
            projection, // a D3 projection; null for pre-projected geometry
            features, // a GeoJSON feature collection
            featureId = (d) => d.id, // given a feature, returns its id
            borders, // a GeoJSON object for stroking borders
            county_borders, // a GeoJSON object for stroking county borders
            outline = projection && projection.rotate
              ? { type: "Sphere" }
              : null, // a GeoJSON object for the background
            unknown = "#ccc", // fill color for missing data
            fill = "white", // fill color for outline
            stroke = "white", // stroke color for borders
            strokeLinecap = "round", // stroke line cap for borders
            strokeLinejoin = "round", // stroke line join for borders
            strokeWidth, // stroke width for borders
            strokeOpacity, // stroke opacity for borders
          } = {}
        ) {
          const zoom = d3.zoom().scaleExtent([1, 2]).on("zoom", zoomed);

          // Compute values.
          const N = d3.map(data, id);
          const V = d3.map(data, value).map((d) => (d == null ? NaN : +d));
          const Im = new d3.InternMap(N.map((id, i) => [id, i]));
          const If = d3.map(features.features, featureId);

          // Compute default domains.
          if (domain === undefined) domain = d3.extent(V);

          // Construct scales.
          // const color = d3.scaleLinear(domain, range);
          const color = scale(domain, range);
          if (unknown !== undefined) color.unknown(unknown);

          // Compute titles.
          if (title !== null) {
            const T = title;
            const O = d3.map(data, (d) => d);
            title = (f, i) => T(f, O[i]);
          }

          // Compute the default height. If an outline object is specified, scale the projection to fit
          // the width, and then compute the corresponding height.
          if (height === undefined) {
            if (outline === undefined) {
              height = 400;
            } else {
              const [[x0, y0], [x1, y1]] = d3
                .geoPath(projection.fitWidth(width, outline))
                .bounds(outline);
              const dy = Math.ceil(y1 - y0),
                l = Math.min(Math.ceil(x1 - x0), dy);
              projection
                .scale((projection.scale() * (l - 1)) / l)
                .precision(0.2);
              height = dy;
            }
          }

          // Construct a path generator.
          const path = d3.geoPath(projection);

          const svg = d3
            .select("#map")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .on("click", reset);

          const g = svg.append("g");

          // svg
          //   .append("g")
          //   .selectAll("path")
          //   .data(features.features)
          //   .join("path")
          //   .attr("fill", (d, i) => color(V[Im.get(If[i])]))
          //   .attr("id", (d) => "county" + d.id)
          //   .attr("d", path)
          //   // .attr("stroke", "#bfbfbf")
          //   // .attr("stroke-width", 0.6)
          //   // .attr("stroke-linejoin", "round")
          //   .append("title")
          //   .text((d, i) => title(d, Im.get(If[i])));

          const counties = g
            .append("g")
            .selectAll("path")
            .data(features.features)
            .join("path")
            .attr("fill", (d, i) => color(V[Im.get(If[i])]))
            .attr("id", (d) => "county" + d.id)
            .attr("d", path)
            .attr("stroke", "#bfbfbf")
            .attr("stroke-width", 0.6)
            .attr("stroke-linejoin", "round");
          // .append("title")
          // .text((d, i) => title(d, Im.get(If[i])));

          const states = g
            .append("g")
            .attr("fill", "transparent")
            .attr("cursor", "pointer")
            .selectAll("path")
            .data(topojson.feature(us, us.objects.states).features)
            .join("path")
            .on("click", clicked)
            .attr("stroke", "black")
            .attr("stroke-linecap", strokeLinecap)
            .attr("stroke-linejoin", strokeLinejoin)
            .attr("stroke-width", 0.8)
            .attr("d", path);

          // create a tooltip
          // var tooltip = d3
          //   .select("#map")
          //   .append("div")
          //   .attr("class", "tooltip")
          //   .style("position", "absolute")
          //   .style("visibility", "hidden");
          // // .text("I'm a circle!");

          // //
          // data.forEach(function (d) {
          //   tooltip.innerHTML = d.county;
          //   let selectedCounty = document.getElementById("county" + d.fips_id);
          //   // .select(".div.tooltip")
          //   selectedCounty.onmouseover = function () {
          //     console.log(tooltip.innerHTML);
          //     return tooltip.style("visibility", "visibile");
          //   };
          //   // .on("mouseover", function () {
          //   //   return tooltip.style("visibility", "visibile");
          //   // })
          //   // .on("mouseout", function () {
          //   //   return tooltip.style("visibility", "hidden");
          //   // });
          //   // console.log(tooltip.innerHTML);
          // });

          let cl = 0;

          svg.call(zoom).on("wheel.zoom", null).on("dblclick.zoom", null);
          // svg.call(zoom);

          function reset() {
            states.transition().style("stroke", null);
            svg
              .transition()
              .duration(750)
              .call(
                zoom.transform,
                d3.zoomIdentity,
                d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
              );
          }

          function clicked(event, d) {
            cl = cl + event.detail;
            const [[x0, y0], [x1, y1]] = path.bounds(d);
            event.stopPropagation();
            states.transition().style("stroke", null);
            d3.select(this).raise();
            if (cl % 2 == 0) {
              reset();
            } else {
              svg
                .transition()
                .duration(750)
                .call(
                  zoom.transform,
                  d3.zoomIdentity
                    .translate(width / 2, height / 2)
                    .scale(
                      Math.min(
                        8,
                        0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)
                      )
                    )
                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
                  d3.pointer(event, svg.node())
                );
            } //not even
          }

          function zoomed(event) {
            const { transform } = event;
            g.attr("transform", transform);
            counties.attr("stroke-width", 0.6 * Math.sqrt(1 / transform.k));
            states.attr("stroke-width", Math.sqrt(1 / transform.k));
          }

          svg.node();
        }
      } //ready
      ready();

      function processInputs(data) {
        let inputs = getInputs();
        const columnNames = Object.keys(data[0]);
        // set result to 0
        for (let i = 0; i < data.length; ++i) {
          data[i].result = 0;
        }
        // console.table(data);
        for (let i = 3; i < columnNames.length - 1; i++) {
          // skip result
          let carrentInput = inputs.find(
            (inputs) => inputs.id === columnNames[i]
          );
          if (!carrentInput) {
            continue;
          }
          let sortedData = sortDataDesc(data, carrentInput.id);
          let slicedData = [];
          if (carrentInput.val < 2) {
            slicedData = sortedData;
          } else {
            slicedData = sortedData.slice(
              0,
              Math.round(sortedData.length * (1 - carrentInput.val / 10) + 1)
            );
          }
          for (let ind = 0; ind < slicedData.length; ind++) {
            for (let j = 0; j < data.length; ++j) {
              if (data[j].fips_id === slicedData[ind].fips_id) {
                data[j].result += parseInt(slicedData[ind][carrentInput.id]);
              }
            }
          }
        } //for
        for (let i = 0; i < data.length; ++i) {
          data[i].result = Math.round(data[i].result / inputs.length);
        }
        // console.table(sortedResults);
        return data;
      } // end processInputs()

      function getInputs() {
        let inputsVals = [];
        let inputsHTMLcollection = document.querySelectorAll(
          "input[type = range]"
        );
        //filter only visible inputs
        let inputs = Array.from(inputsHTMLcollection).filter(
          (x) => x.offsetWidth !== 0 || x.offsetHeight !== 0
        );
        for (let i = 0; i < inputs.length; ++i) {
          let id = inputs[i].id;
          let val = inputs[i].value;
          let labelId = id + "Val";
          document.getElementById(labelId).innerHTML = val;
          inputsVals.push({ id: id, val: val });
        }
        return inputsVals;
      } //getInputs

      async function changeColor() {
        processInputs(data);
        let maxResult = sortDataDesc(data, "result")[0].result;
        // console.table(sortedResults);
        let treshold = maxResult / range.length; //range.length = 9
        // console.log("treshold", treshold, data.length, range.length);
        for (let i = 0; i < data.length; ++i) {
          let elem = document.getElementById("county" + data[i].fips_id);
          if (elem) {
            if (data[i].result < treshold) {
              elem.style.fill = range[0];
            } else if (
              (data[i].result < 2 * treshold) &
              (data[i].result >= treshold)
            ) {
              elem.style.fill = range[1];
            } else if (
              (data[i].result < 3 * treshold) &
              (data[i].result >= 2 * treshold)
            ) {
              elem.style.fill = range[2];
            } else if (
              (data[i].result < 4 * treshold) &
              (data[i].result >= 3 * treshold)
            ) {
              elem.style.fill = range[3];
            } else if (
              (data[i].result < 5 * treshold) &
              (data[i].result >= 4 * treshold)
            ) {
              elem.style.fill = range[4];
            } else if (
              (data[i].result < 6 * treshold) &
              (data[i].result >= 5 * treshold)
            ) {
              elem.style.fill = range[5];
            } else if (
              (data[i].result < 7 * treshold) &
              (data[i].result >= 6 * treshold)
            ) {
              elem.style.fill = range[6];
            } else if (
              (data[i].result < 8 * treshold) &
              (data[i].result >= 7 * treshold)
            ) {
              elem.style.fill = range[7];
            } else if (
              (data[i].result <= 9 * treshold) &
              (data[i].result >= 8 * treshold)
            ) {
              elem.style.fill = range[8];
            } else {
              elem.style.fill = null;
            }
            // if (isNaN(sortedResults[sortedResults.length - 1].result)) {
            //   elem.style.fill = null;
            // }
          } else {
            console.log("elem not found");
          }
        }
      } // end changeColor()
      function removeById(id) {
        let sliderid = id + "Slider";
        let elem = document.getElementById(sliderid);
        elem.style.display = "none";
        let lineId = id + "Line";
        let lineElem = document.getElementById(lineId);
        lineElem.style.display = "block";
        changeColor();
      }
      function addById(id) {
        let sliderid = id + "Slider";
        let elem = document.getElementById(sliderid);
        elem.style.display = "block";
        let lineId = id + "Line";
        let lineElem = document.getElementById(lineId);
        lineElem.style.display = "none";
        changeColor();
      }
      function sortDataAsc(data, key) {
        return data.sort((a, b) => a[key] - b[key]);
      } //end sortData
      function sortDataDesc(data, key) {
        return data.sort((a, b) => b[key] - a[key]);
      } //end sortData
      function excludeAlaska() {
        const AlaskaHawaiiFips = [
          "02013",
          "02016",
          "02020",
          "02050",
          "02060",
          "02068",
          "02070",
          "02090",
          "02100",
          "02105",
          "02110",
          "02122",
          "02130",
          "02150",
          "02158",
          "02164",
          "02170",
          "02180",
          "02185",
          "02188",
          "02195",
          "02198",
          "02220",
          "02230",
          "02240",
          "02261",
          "02270",
          "02275",
          "02282",
          "02290",
          "15001",
          "15003",
          "15005",
          "15007",
          "15009",
        ];
        const AlaskaHawaiiStateFips = ["02", "15"];
        us.objects.counties.geometries = us.objects.counties.geometries.filter(
          function (d) {
            return AlaskaHawaiiFips.indexOf(d.id) == -1;
          }
        );
        us.objects.states.geometries = us.objects.states.geometries.filter(
          function (d) {
            return AlaskaHawaiiStateFips.indexOf(d.id) == -1;
          }
        );
      }
    </script>
  </body>
</html>
